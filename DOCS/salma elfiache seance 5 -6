Lors des sÃ©ances 5 et 6 du projet dâ€™arrosage automatique, jâ€™ai principalement avancÃ© sur les deux tÃ¢ches qui mâ€™ont Ã©tÃ© attribuÃ©es :
La conception du schÃ©ma algorithmique du systÃ¨me .
La programmation du module horloge DS3231M.
Pendant la sÃ©ance, jâ€™ai dÃ©fini lâ€™ensemble des Ã©tats du systÃ¨me et leurs transitions.
Voici le fonctionnement dÃ©taillÃ© que jâ€™ai construit :
ğŸ”µ E0 â€“ Mode Deep Sleep
Lâ€™ESP32 reste en veille profonde pour minimiser la consommation.
Le coprocesseur ULP continue de compter la pluie via le pluviomÃ¨tre.
Le rÃ©veil se fait par :
interruption RTC (heure programmÃ©e),
ou appui sur un bouton.
ğŸ”µ E1 â€“ Lecture des donnÃ©es horloge (RTC)
Ã€ chaque rÃ©veil du systÃ¨me :
lecture de la date/heure,
vÃ©rification si un cycle dâ€™arrosage doit dÃ©marrer,
rÃ©initialisation du compteur de pluie toutes les 24h.
Transition :
si ce nâ€™est pas lâ€™heure dâ€™arroser â†’ retour E5 (DeepSleep)
sinon â†’ E2
ğŸ”µ E2 â€“ Lecture des capteurs
Le systÃ¨me lit :
humiditÃ© du sol,
quantitÃ© de pluie accumulÃ©e (ULP),
tempÃ©rature,
humiditÃ© de lâ€™air.
Ces valeurs servent Ã  autoriser ou empÃªcher lâ€™arrosage selon les conditions mÃ©tÃ©o.
Transition :
si conditions dÃ©favorables â†’ retour E5
sinon â†’ E3
ğŸ”µ E3 â€“ PrÃ©paration de lâ€™arrosage
Le systÃ¨me :
charge la liste des zones Ã  arroser,
calcule la durÃ©e totale,
active lâ€™Ã©cran TFT pour afficher les informations.
Câ€™est un Ã©tat de transition avant lâ€™activation rÃ©elle des vannes.
ğŸ”µ E4 â€“ Arrosage
Automate de type Moore :
activation des Ã©lectrovannes,
maintien du dÃ©bit pendant la durÃ©e programmÃ©e,
gestion du timer global.
Transition :
si durÃ©e terminÃ©e â†’ E5
sinon â†’ rester en E4
ğŸ”µ E5 â€“ Fin & Retour Deep Sleep
dÃ©sactivation toutes les vannes,
extinction de lâ€™Ã©cran,
sauvegarde Ã©ventuelle de donnÃ©es,
retour en mode Deep Sleep.
------------------------------------------------
AprÃ¨s le schÃ©ma algorithmique, jâ€™ai commencÃ© la programmation du RTC, qui est essentiel pour :
rÃ©veiller le systÃ¨me aux bonnes heures,
gÃ©rer les cycles dâ€™arrosage quotidiens,
afficher la date et lâ€™heure sur le TFT.
---Initialisation de lâ€™horloge
Voici le code sur lequel jâ€™ai travaillÃ© :
void setup() {
  //---------- CLK INIT -----------------
  Serial.begin(9600);

  // Initialisation I2C
  Wire.begin(22, 21);   // broches ESP32 SDA=22, SCL=21 
  Serial.println("Initialisation RTC...");

  while(!rtc.begin()) {
    Serial.println("RTC non dÃ©tectÃ© !");
  }

  // Si l'RTC a perdu l'heure â†’ on met l'heure du compilateur
  if (rtc.lostPower()) {
    Serial.println("RTC a perdu l'heure, initialisation...");
    rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
  }
}
Ce que fait ce code :
initialise le port sÃ©rie,
configure le bus IÂ²C sur les broches du ESP32,
dÃ©tecte la prÃ©sence du module RTC,
vÃ©rifie sâ€™il a perdu lâ€™heure (perte dâ€™alimentation),
si oui â†’ il le rÃ©initialise Ã  la date/heure de compilation
--Affichage de lâ€™heure sur lâ€™Ã©cran TFT
Jâ€™ai ensuite dÃ©veloppÃ© une fonction permettant dâ€™afficher lâ€™heure en haut de lâ€™Ã©cran TFT :

void AfficherHeure(){
  tft.setTextSize(1);
  tft.setTextColor(TFT_BLACK, TFT_LIGHTGREY);

  DateTime now = rtc.now(); 
  char TimeBuffer[64];
  sprintf(TimeBuffer,"%02d/%02d/%04d %02d:%02d:%02d", 
          now.day(), now.month(), now.year(),
          now.hour(), now.minute(), now.second());

  Serial.printf(TimeBuffer);
  tft.drawString(TimeBuffer, 5, 10, 2);
}
